
<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Programming in Open Dylan &mdash; Getting Started with the Open Dylan IDE</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="_static/opendylan.org/css/opendylan-docs.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="Creating and Using Projects" href="projects.html" />
    <link rel="prev" title="Fixing Bugs" href="expanding.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Getting Started with the Open Dylan IDE
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick-start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="expanding.html">Fixing Bugs</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Programming in Open Dylan</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#projects">Projects</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#projects-and-libraries">Projects and libraries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#projects-and-deliverables">Projects and deliverables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-new-projects">Creating new projects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#project-files">Project files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#project-components">Project components</a></li>
<li class="toctree-l3"><a class="reference internal" href="#projects-on-disk">Projects on disk</a></li>
<li class="toctree-l3"><a class="reference internal" href="#projects-in-the-development-environment">Projects in the development environment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#development-models">Development models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#interactive-and-incremental-development">Interactive and incremental development</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#compilation">Compilation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#compiler-databases">Compiler databases</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compilation-modes">Compilation modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#versioning">Versioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binding">Binding</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-build-cycle">The build cycle</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linkers">Linkers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#executing-programs">Executing programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#starting-applications-up-from-within-open-dylan">Starting applications up from within Open Dylan</a></li>
<li class="toctree-l3"><a class="reference internal" href="#application-and-library-initialization">Application and library initialization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#source-database-and-run-time-views">Source, database, and run-time views</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="projects.html">Creating and Using Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="browsing.html">Learning More About an Application</a></li>
<li class="toctree-l1"><a class="reference internal" href="debug.html">Debugging and Interactive Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="remotedbg.html">Remote Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="coloring.html">Dispatch Optimization Coloring in the Editor</a></li>
<li class="toctree-l1"><a class="reference internal" href="delivery.html">Delivering Dylan Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="editopt.html">The Interactive Editor</a></li>
<li class="toctree-l1"><a class="reference internal" href="com-projects.html">Creating COM Projects</a></li>
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Getting Started with the Open Dylan IDE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Programming in Open Dylan</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/model.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="programming-in-open-dylan">
<h1>Programming in Open Dylan<a class="headerlink" href="#programming-in-open-dylan" title="Permalink to this headline">¶</a></h1>
<p>Now we have taken a tour of Open Dylan using the pre-written
Reversi application, we take a step back to look at the programming
model in Open Dylan, and to review the features of the development
environment and the Dylan compiler.</p>
<div class="section" id="projects">
<span id="index-0"></span><h2>Projects<a class="headerlink" href="#projects" title="Permalink to this headline">¶</a></h2>
<p>In Open Dylan, all development work is done in terms of <em>projects</em>.
Projects are the development environment and compiler’s way of
representing Dylan libraries.</p>
<p>A project consists mainly of a list of the source files that define the
library, but also contains information about how to compile the library.</p>
<p>While it is possible to edit text files that are not associated with any
project, nearly all other programming tasks in Open Dylan take
place within the context of a project.</p>
<div class="section" id="projects-and-libraries">
<h3>Projects and libraries<a class="headerlink" href="#projects-and-libraries" title="Permalink to this headline">¶</a></h3>
<p>A project represents a single Dylan library. Think of a project as
something that gathers together all the information Open Dylan
needs to be able to compile a particular library.</p>
<p>For example, earlier in this manual, we worked with the Reversi project.
The Reversi project represents a single Dylan library, called Reversi.</p>
</div>
<div class="section" id="projects-and-deliverables">
<h3>Projects and deliverables<a class="headerlink" href="#projects-and-deliverables" title="Permalink to this headline">¶</a></h3>
<p id="index-1">You can create deliverable applications, libraries, and components from
projects. Projects can be built into executable (.EXE) or dynamic-link
library (.DLL) files.</p>
<p>Use the <em>Project</em> menu for project building. See <a class="reference internal" href="delivery.html"><span class="doc">Delivering Dylan Applications</span></a>,
for details of delivery to customers.</p>
<p>When we worked with the Reversi project, we built an executable from it,
but we could just as easily have built a DLL. See <a class="reference internal" href="projects.html#project-settings"><span class="std std-ref">Project settings</span></a>
for details.</p>
</div>
<div class="section" id="creating-new-projects">
<span id="index-2"></span><h3>Creating new projects<a class="headerlink" href="#creating-new-projects" title="Permalink to this headline">¶</a></h3>
<p>Open Dylan includes a New Project wizard for creating new projects.</p>
<p>The New Project wizard asks questions about what you are going to
develop, and then creates a new project configured to help you get
working quickly. See <a class="reference internal" href="projects.html#creating-new-project"><span class="std std-ref">Creating a new project</span></a>.</p>
<p>You can also create a project if you have a Dylan Library Interchange
Description (LID) file for it. LID files have a .LID extension. When you
open a LID file in the development environment, it is converted into a
project file and opened in a project window. (This process does not
modify the original LID file on disk.) See
<a class="reference internal" href="projects.html#project-files-and-lid-files"><span class="std std-ref">Project files and LID files</span></a>.</p>
</div>
<div class="section" id="project-files">
<span id="index-3"></span><h3>Project files<a class="headerlink" href="#project-files" title="Permalink to this headline">¶</a></h3>
<p>Open Dylan stores projects on disk in <em>project files</em>. Project
files have the same name as the project, with the extension <em>.</em> HDP.
Thus a project called Hello is stored in the file <em>Hello.hdp</em>.
(Projects get their names in the New Project wizard or, if they were
created by conversion from a LID file, get their name from the name of
the library that the LID file defines.)</p>
<p>Project files are the files you select when you want to open a project
or add it to another project as a subproject.</p>
<p>The development environment tools automatically save changes to project
files. For example, if you add a new source file to a project, the
change is saved to disk immediately.</p>
</div>
<div class="section" id="project-components">
<span id="index-4"></span><h3>Project components<a class="headerlink" href="#project-components" title="Permalink to this headline">¶</a></h3>
<p>We now describe the components of a project in more detail. Every
project consists of:</p>
<dl>
<dt>A Dylan library</dt><dd><p>Every project defines a single Dylan library. We call this library the
“library of the project” or, for clarity, the <em>main</em> library of the
project, to distinguish it from other libraries that the project uses.</p>
</dd>
<dt>A project name</dt><dd><p>Every project has a name. When you create a new project with the New
Project wizard, the wizard uses this name to generate default names for
initial files, libraries and modules in the new project. The compiler
uses the project name to generate default names for the executables and
other files it produces during compilation. In both cases, you can
override the defaults.</p>
</dd>
<dt>Source code files, and other files</dt><dd><p>Every project includes source code files. Projects created with the New
Project wizard will have a <em>library.dylan</em> file (which defines the
project’s library); a <em>module.dylan</em> file (which defines the modules of
the library); and at least one other Dylan source code file containing
definitions and expressions.</p>
<p>Projects can also include Windows resource files, static libraries (.LIB
files), and text files. The compiler ignores any file it does not
recognize. This flexibility allows such things as including README files
in a project.</p>
</dd>
<dt>Subprojects</dt><dd><p>A project can have <em>subprojects</em>. Subprojects are other projects that
are included in a project; they define their own main library, contain
their own source files and may have subprojects themselves. For clarity,
we can call a project a <em>superproject</em> when describing it with reference
to its subprojects.</p>
<p>See <a class="reference internal" href="#the-build-cycle">The build cycle</a> for more on the relationship between projects
and their subprojects.</p>
</dd>
<dt>Version numbers</dt><dd><p>Every project has a major and minor version number. The version numbers
affect the build process for projects. See <a class="reference internal" href="projects.html#link-page"><span class="std std-ref">Link page</span></a> and
<a class="reference internal" href="#the-build-cycle">The build cycle</a>.</p>
</dd>
<dt>Project settings</dt><dd><p>Every project has settings. Among these settings are:</p>
<ul class="simple">
<li><p>The list of source code files and their locations on disk.</p></li>
<li><p>Compilation mode options. See <a class="reference internal" href="#id3">Compilation modes</a>.</p></li>
<li><p>Debugging options. See <a class="reference internal" href="debug.html#debugger-options"><span class="std std-ref">Debugger options</span></a>.</p></li>
<li><p>The list of subprojects the project uses.</p></li>
<li><p>The locations on disk of the subprojects.</p></li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="projects-on-disk">
<span id="index-5"></span><span id="id1"></span><h3>Projects on disk<a class="headerlink" href="#projects-on-disk" title="Permalink to this headline">¶</a></h3>
<p>A project consists of several files and folders on disk.</p>
<p>First, all the information necessary to build the project is stored in a
<em>project file</em> (.HDP file). Then there are the Dylan source files, and
possibly Windows resource and static library (.LIB) files, that make up
the code for the project.</p>
<p>The files that make up a project are stored in a folder called the
<em>project folder</em>, which normally has the same name as the project. The
files are stored in the project folder and in several subfolders of the
project folder. The files themselves can refer to other folders where
subprojects and used libraries are stored.</p>
<p>The project folder contains the following files and subfolders:</p>
<ul>
<li><p>The project file. (.HDP file.)</p></li>
<li><p>The source code files. (.DYLAN files)</p></li>
<li><p>The <em>bin</em> folder.</p>
<p>This folder holds the executable (.EXE) or DLL (.DLL) file produced from
the project.</p>
<p>In addition, the DLLs of the project’s subprojects are automatically
copied into this folder, so that they can be found when you execute your
project’s application.</p>
</li>
<li><p>The <em>project</em> <em>-build</em> folder.</p>
<p>This folder, whose name begins with the name of the project, holds a
number of intermediate files produced during builds. You will never have
to do anything with these intermediate files.</p>
<p>The folder also contains the <em>compiler database</em> file for the project.
This file has the same name as the project and the extension .DDB. See
<a class="reference internal" href="#id2">Compiler databases</a> for more details.</p>
<p>You can remove the compiler database and intermediate files with
<strong>Project &gt; Remove Build Products</strong>. This forces a complete recompilation
of a project next time you build it.</p>
</li>
<li><p>The <em>lib</em> folder.</p>
<p>This folder holds the <em>linker</em> file for the project. This file has the
same name as the project and the extension .LIB or .DEFS. This file is
needed for other projects to be able to link against the project, a
process that is part of using a project as a subproject.</p>
<p>The extension is .LIB if you are using the Microsoft linker, or .DEFS if
you are using the GNU linker.</p>
</li>
<li><p>The <em>release</em> folder.</p>
<p>This folder holds a stand-alone version of the project’s application,
suitable for redistribution to customers or other third parties without
a copy of Open Dylan on their system. It is created when you choose
the <strong>Project &gt; Make Release</strong> command.</p>
</li>
</ul>
</div>
<div class="section" id="projects-in-the-development-environment">
<h3>Projects in the development environment<a class="headerlink" href="#projects-in-the-development-environment" title="Permalink to this headline">¶</a></h3>
<p>The Open Dylan development environment offers a variety of ways to
examine and manipulate projects. You can view a single project in
multiple windows at the same time. You can also have more than one
project open in the environment at a time.</p>
<p>Apart from the main window and dialog boxes, windows in Open Dylan
are generally instances of programming tools. The tools provide views
onto different pieces of a project, or sometimes different views of the
same pieces.</p>
<p>For example, you might want to have editor windows open on multiple
files in the project, as well as browser windows to show you structural
views and debugger windows to show you stack backtraces or other
information from a running program.</p>
<p>As we saw when touring the environment with the Reversi example,
Open Dylan offers:</p>
<ul class="simple">
<li><p>A project window.</p></li>
<li><p>A debugger for examining and interacting with paused application
threads associated with open Dylan projects.</p></li>
<li><p>A browser for examining the contents and properties of projects and
of the objects in paused application threads associated with open
Dylan projects.</p></li>
<li><p>An editor for source files. Editors are most often invoked from other
windows on a project, but can be invoked on files outside the context
of a project.</p></li>
</ul>
</div>
</div>
<div class="section" id="development-models">
<h2>Development models<a class="headerlink" href="#development-models" title="Permalink to this headline">¶</a></h2>
<p>The process of development in Open Dylan can be much the same as in
interactive development environments for other languages. Applications
written in Dylan can be developed in the same way as applications
written in static languages like C and C++, for instance.</p>
<div class="figure align-center" id="id6">
<img alt="_images/model-2.png" src="_images/model-2.png" />
<p class="caption"><span class="caption-text">“Static” development model.</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>You can also develop applications in a more dynamic fashion, using
features in the debugger and browser tools that allow you to interact
with a running application. With these dynamic, interactive features,
you can test bug fixes on the fly and keep your application running
before committing to a rebuild.</p>
<div class="figure align-center" id="id7">
<img alt="_images/model-4.png" src="_images/model-4.png" />
<p class="caption"><span class="caption-text">“Dynamic” development model.</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="interactive-and-incremental-development">
<h3>Interactive and incremental development<a class="headerlink" href="#interactive-and-incremental-development" title="Permalink to this headline">¶</a></h3>
<p>Open Dylan offers both interactive and incremental development
features. It is important to distinguish them clearly:</p>
<p>Incremental development is the ability to recompile portions of a
project and save the resulting object code. By contrast, some
compilation systems require that the entire project be recompiled in
response to any change, however small. Open Dylan always performs
incremental compilations when it can, to keep build times as short as
possible.</p>
<p>Interactive development is the ability to execute code fragments,
including definitions and redefinitions, in a running program. Open
Dylan offers interactive development via the debugger’s interaction
pane. The object code produced during interactive development is not
saved, but just patched into the running program and added to the
in-memory <em>compiler database</em> (see <a class="reference internal" href="#id3">Compilation modes</a>). The
object code is lost when the program terminates.</p>
</div>
</div>
<div class="section" id="compilation">
<h2>Compilation<a class="headerlink" href="#compilation" title="Permalink to this headline">¶</a></h2>
<p>This section discusses compilation modes, compiler databases,
optimization (including loose and tight binding), the build cycle
algorithm, and linkers.</p>
<div class="section" id="compiler-databases">
<span id="index-6"></span><span id="id2"></span><h3>Compiler databases<a class="headerlink" href="#compiler-databases" title="Permalink to this headline">¶</a></h3>
<p>When compiling a project, Open Dylan produces a compiler database
which models the project. The database provides a rich source of
information to Open Dylan tools about the contents, properties, and
relationships between source code definitions, libraries, and modules.</p>
<p>A project’s compiler database is used when browsing and debugging the
project, and is also used when compiling other projects that use the
project.</p>
<p>The compiler database for a project does not exist until the project has
been built for the first time. Before then, if you try to do anything
that requires the database, the development environment will ask you if
you want to create it.</p>
<p>Once the compiler database has been built, the development environment
will ensure it is kept up to date with each recompilation of the
project.</p>
<p>Open Dylan stores project files on disk for persistence between
sessions. When you close a project, the development environment checks
whether the database has changed since it was last saved, and if it has
it asks you if you want to save the database. (You can use <strong>File &gt; Save
Compiler Database</strong> from the project window to save the compiler database
at other times, if necessary.) When you re-open the project later, the
database is read into memory from the disk file, if it exists.</p>
<p>Compiler database files have a .DDB suffix.</p>
</div>
<div class="section" id="compilation-modes">
<span id="index-7"></span><span id="id3"></span><h3>Compilation modes<a class="headerlink" href="#compilation-modes" title="Permalink to this headline">¶</a></h3>
<p>The Dylan language encourages programmers to write programs that can be
compiled as efficiently as programs written in static languages. By
adding type declarations and sealing to your project code, the Open
Dylan compiler can optimize it very successfully.</p>
<p>However, the best optimizations come at the costs of longer build times,
and less symbolic information in the debugger. During the larger
proportion of your project’s development, you want projects to build
quickly and to be easier to debug. When it is time to deliver your
product, you will want to turn all the code optimizations on even at the
expense of debugging information and compilation speed.</p>
<p>Like other compilation systems, Open Dylan allows you to switch
between both styles of compilation. For any project, you can specify the
style of compilation to perform by choosing <strong>Project &gt; Settings</strong> in any
window with a <strong>Project</strong> menu, and then choosing the Compile property
page.</p>
<p>That page offers two mode choices:</p>
<ul class="simple">
<li><p>Interactive Development mode</p></li>
<li><p>Production mode</p></li>
</ul>
<p id="index-8">You should do the majority of your work on a project in Interactive
Development mode. When compiling a project in this mode, the compiler
does not perform as many optimizations as it can, and is not as strict
about error checking as it can be. The idea here is to keep compilation
times as short as possible.</p>
<p>This mode keeps symbolic information in the compiled code that will make
debugging work easier. Also, if your project was compiled in this mode
you will be able to do more interactive work in the debugger’s
interaction pane, including redefinition. However, compiled code will
not be as fast as it can be.</p>
<p id="index-9">When your project work is nearing completion, and you want to see the
compiled version running as fast as possible, switch to compiling the
project in Production mode. Production mode turns on all compiler
optimizations. However, build times will be slower than in Interactive
Development mode, and debugging and interaction will be more limited.</p>
<p>When you have switched to Production mode, you can use Open Dylan’s
<em>optimization coloring</em> feature to highlight inefficiencies in your
code. This feature colors source code so that you can see where
optimizations did and did not occur. Adding type declarations and
sealing will secure new optimizations, which you can verify by
refreshing the coloring after rebuilding the project. See
<a class="reference internal" href="coloring.html"><span class="doc">Dispatch Optimization Coloring in the Editor</span></a>.</p>
</div>
<div class="section" id="versioning">
<span id="id4"></span><h3>Versioning<a class="headerlink" href="#versioning" title="Permalink to this headline">¶</a></h3>
<p>A project can have major and minor version numbers that will be recorded
in the DLL or EXE that the project builds. You can enter these numbers
on the <strong>Project &gt; Settings…</strong> dialog’s Link page.</p>
<p>Open Dylan uses version numbers at compile time and run time to
determine if compatible versions of Dylan libraries are in use.</p>
<p>The rules differ for compilation in Interactive Development mode and
Production mode. For applications compiled in Interactive Development
mode, the procedure at run time for initializing a library involves
checking the major and minor versions of the Dylan libraries used by the
library being initialized. If the major version number of a used library
does not match that of the library using it, or the minor version number
of a used library is lower than that of the library using it, the
Open Dylan run-time system signals an error.</p>
<p>In Production mode, the run-time check ignores the user-supplied version
numbers and checks whether the used library is the very same one that
was used at compile time. If the library is different, a run-time error
is signalled even if the version is the same.</p>
</div>
<div class="section" id="binding">
<span id="index-10"></span><h3>Binding<a class="headerlink" href="#binding" title="Permalink to this headline">¶</a></h3>
<p>Interactive Development mode and Production mode are in fact
combinations of some lower-level compiler modes. Open Dylan
presents these two compilation modes to make development simpler, but
some understanding of these lower-level modes is useful. They are <em>loose
binding</em> and <em>tight binding</em>.</p>
<ul class="simple">
<li><p>Loose binding This is a way of compiling code that makes no use of
the type information available in the source. When the compiler is
run using loose binding, it considers only names and macro
definitions. References to objects and types are always made
indirectly through the objects’ names, so that the objects can be
changed without forcing recompilation of code that uses them.</p></li>
<li><p>Tight binding This is a way of compiling code that uses all type
information available in order to drive optimizations. This type
information includes declared types and some inferred types. Tight
binding bypasses names, referencing objects and types directly.
Amongst other optimizations, tight bindings inlines some methods,
performs tail-call elimination, and removes unused code. These
optimizations can affect the information seen in the debugger.</p></li>
</ul>
<p>Code can be loosely or tightly bound within a library, and it can be
loosely or tightly bound with respect to other libraries. If code within
a library is loosely bound, other libraries will be loosely bound to it.
Similarly, if code is tightly bound within a library, other libraries
will bind tightly to it.</p>
<p>The code within all libraries that Open Dylan supplies—the system
libraries—is tightly bound. This means that all libraries you develop
will bind tightly to whichever of the system libraries you use.</p>
<p>When libraries are compiled in Interactive Development mode, they are
loosely bound internally, and therefore libraries that use them will be
loosely bound to them. When libraries are compiled in Production mode,
they are tightly bound internally, and therefore libraries that use them
are tightly bound to them.</p>
</div>
<div class="section" id="the-build-cycle">
<span id="index-11"></span><h3>The build cycle<a class="headerlink" href="#the-build-cycle" title="Permalink to this headline">¶</a></h3>
<p>Building an application or DLL from a project consists of up to three
phases:</p>
<ol class="arabic simple">
<li><p>Building the subprojects.</p></li>
<li><p>Compiling some or all of the project source code.</p></li>
<li><p>Linking the project.</p></li>
</ol>
<p>For efficiency, when the compiler is asked to build a project it
minimizes the number of these phases that it performs, using the
following decision rules:</p>
<ul class="simple">
<li><p>If phase 2 or 3 is performed, the project is considered changed.</p></li>
<li><p>A <em>clean build</em> always performs all phases for the project and its
subprojects.</p></li>
</ul>
<p>You can ask for a clean build by choosing <strong>Project &gt; Clean Build</strong> in any
window that has a <strong>Project</strong> menu.</p>
<ul class="simple">
<li><p>A build command is always recursively performed on subprojects (phase
1).</p></li>
<li><p>If the major version number of any subproject has been changed, then
all of the source code in the project is recompiled.</p></li>
<li><p>If the project is tightly bound to any subproject which has changed,
then all the source code in the project is recompiled.</p></li>
<li><p>If the project is tightly bound to itself, and if any source code in
the project has changed, then all the source code in the project is
recompiled.</p></li>
<li><p>If the project is loosely bound to itself, then any source code files
that have changed are recompiled. Additionally, files that depend on
those changes (such as through macro usage) are recompiled.</p></li>
<li><p>If the project or any of its subprojects has changed, then the
project is relinked.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To ensure change propagation according to these rules, you
should always increment the major version number of a project after
altering any macro definitions in it.</p>
</div>
</div>
<div class="section" id="linkers">
<span id="index-12"></span><h3>Linkers<a class="headerlink" href="#linkers" title="Permalink to this headline">¶</a></h3>
<p>Open Dylan offers you a choice of linkers to use to link your Dylan
programs. The default linker is a GNU linker. If you own Microsoft
Developer Studio, you can use Microsoft’s linker instead. See the Linker
page of the main window’s <strong>Options &gt; Environment Options…</strong> dialog.</p>
</div>
</div>
<div class="section" id="executing-programs">
<h2>Executing programs<a class="headerlink" href="#executing-programs" title="Permalink to this headline">¶</a></h2>
<p>This section discusses running applications within Open Dylan (and
the benefits of doing so), and the process of library initialization in
an application.</p>
<div class="section" id="starting-applications-up-from-within-open-dylan">
<span id="index-13"></span><h3>Starting applications up from within Open Dylan<a class="headerlink" href="#starting-applications-up-from-within-open-dylan" title="Permalink to this headline">¶</a></h3>
<p>An application written in Dylan cannot be started and later connected to
Open Dylan and its project. If you want to be able to debug an
application and browse its compiler database within Open Dylan, you
must start it up by opening its project and starting it with
<strong>Application &gt; Start</strong>. This starts the application up under the
debugger, providing the development environment with a connection to the
application and the capabilities necessary to control its execution and
to interact with it.</p>
</div>
<div class="section" id="application-and-library-initialization">
<span id="index-14"></span><span id="id5"></span><h3>Application and library initialization<a class="headerlink" href="#application-and-library-initialization" title="Permalink to this headline">¶</a></h3>
<p>When a Dylan application starts up, it begins by loading the libraries
that it uses. Each library performs its own initialization when it is
loaded. In general, libraries are loaded in a demand-driven, depth-first
order. However, you should not depend on used libraries being loaded in
the same order that they are mentioned in a library definition.</p>
<p>Library initialization is performed by executing the code which
comprises the library, in the order in which it is defined by the
library’s project. This means that the order of the Dylan source files
in a project is significant, and that the order of definitions and
expressions in a Dylan file is significant.</p>
<p>Definitions in a Dylan library are not, in general, said to execute.
Rather, they define the static structure of a program. This is true of
variables and constants initialized to literal values or other values
computable at compile time, and it is also true of classes and
functions. Forward references to such objects are allowed, and all such
objects are created at the start of library initialization, before
expressions are executed. Some definitions rely on the computation of
run-time values; in these cases, forward references may not be allowed.</p>
<p>Expressions in a Dylan library are executed in the order in which they
appear in the project, and the last expression in a project should be a
call to a project’s start function.</p>
</div>
</div>
<div class="section" id="source-database-and-run-time-views">
<span id="source-database-runtime-views"></span><span id="index-15"></span><h2>Source, database, and run-time views<a class="headerlink" href="#source-database-and-run-time-views" title="Permalink to this headline">¶</a></h2>
<p>We have seen that Open Dylan provides several tools to allow us to
view projects in different ways. Some tools can look at the source
representation of a project, while others can look at the run-time
representation—the threads of a running application built from a
project.</p>
<p>It is useful to think of there being three “worlds” in which we can
simultaneously view projects: source, database, and run-time.</p>
<p>Every project has a representation in source code. We view this source
representation with the editor mainly, but the debugger’s source pane
can show us the source code for a function on the stack, and the browser
can show the source for some kinds of object in its Source page.</p>
<p>When we build a project, the compiler database that is created provides
a second representation. Then, when we run the application or DLL we
have created, the running program is itself a third representation of
the project.</p>
<p>So, at any given time, an object may exist in each of these worlds
simultaneously. The source code of the object may exist in a Dylan
source file, a model of the object may exist in the compiler database,
and the object may be instantiated in a running program.</p>
<p>Editor windows show projects in their source representation only.
Browser windows show information from the compiler database, and, if a
program is running, this database information is combined with
information from the program, so you can see the “live” version of the
object.</p>
<p>The debugger and its interaction pane allows you to view the threads of
running programs, and allows you to execute expressions and definitions
in these threads. When you do this, the running program is modified.
When you enter definitions in this way, the definitions are saved in a
temporary layer of the compiler database so that browsing will continue
to be accurate. However, these temporary changes are not saved to disk
in the compiler database file, nor are they reflected in the project
source code files.</p>
<p>There are ways in which the three worlds can get out of sync. Remember
that if you edit a source code definition, the model of it in the
database will not be updated until you rebuild the project. So, for
instance, if you change the inheritance characteristics of a class, the
change will not be reflected in the browser Superclasses page for that
definition until you rebuild. And if you add new definitions to the
project sources, they will also not be visible until you build the
project again.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="expanding.html" class="btn btn-neutral float-left" title="Fixing Bugs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="projects.html" class="btn btn-neutral float-right" title="Creating and Using Projects" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; <a href="copyright.html">Copyright</a> 2011-2023, Dylan Hackers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>